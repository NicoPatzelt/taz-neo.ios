
// by singh 2012 (hooka, hooka)
//
// attention: don't try to setup css for the divs *that are generated by this code* -
// the code is taking care for everything itself.
//
// *** columnPager ************************************************************************
var columnPager = (function () {
    "use strict"; // disable if callee debugging is wanted

    // *** tools **************************************************************************
    var tools = (function () {

        var debugLevel = 0, // 0: no debugging, 1: less debugging, 2: more debugging

            // test if strict mode is activated
            hasStrictMode = (function () {
		// ### RaKl 
		return true;
                return this === undefined;
            }()),

            // direct interface to logging output, use setter to replace
            logger = function (message) {
                console.log(message);
            },

            // return true if message has to be output at current debug level
            debugLevelManager = function (level) {
                return debugLevel >= level;
            };

        // official high level debug level enquire API throughout this library
        function isDebug(level) {
            return debugLevelManager(level);
        }

        // official low level debug API throughout this library
        function debugWrite(level, caller, msg) {
            if (isDebug(level)) {
                logger("[columnPager] " + (caller ? "@" + caller + ": " : "") + (msg || ""));
            }
        }

        // get call path of current function, doesn't work in strict mode
        // i is stack depth, currently not used
        function callPath(caller, i) {

            if (caller === caller.caller) return "..." + caller.name;

            return caller.caller ? callPath(caller.caller, i + 1) + "." + caller.name : caller.name;
        }

        // official high level debug API throughout this library
        function debug(level, msg) {
            var caller = hasStrictMode ? null : callPath(arguments.callee.caller, 0);
            debugWrite(level, caller, msg);
        }

        // dump infos about renderer
        function debugRenderer() {
            debug(1, "userAgent: " + navigator.userAgent);
        }

        // get integer value of named current computed css style
        function getIntProp(element, propName) {
            return parseInt(document.defaultView.getComputedStyle(element, null).
                               getPropertyValue(propName));
        }

        // true if className is contained in DOM node class attribute
        function hasClass(node, className) {

            if (node.nodeType !== 1) return false;
            var classes = node.className.split(' ');
            for (var i = 0; i < classes.length; i++) {
                if (classes[i].toUpperCase() === className.toUpperCase()) return true;
            }
            return false;
        }

        // add className to DOM node class attribute if not already contained
        function setClass(node, className) {
            if (node.nodeType !== 1 || hasClass(node, className)) {
                return;
            }
            if (!node.className) {
                node.className = className;
            } else {
                node.className = node.className + " " + className;
            }
        }

        // remove className from DOM node class attribute if contained
        function removeClass(node, className) {

            if (node.nodeType !== 1) return false;

            var first = true, classes = node.className.split(' ');

            for (var i = 0; i < classes.length; i++) {
                if (classes[i].toUpperCase() === className.toUpperCase()) continue;
                cl = first ? classes[i] : cl + " " + classes[i];
                first = false;
            }

            node.className = cl;
        }

        // remove id from current Element and assign to new Element, in debug mode
        // assign red background color to current element
        function switchId(element, id) {

            var oldElement = document.getElementById(id);
            if (oldElement) {
                oldElement.removeAttribute("id");
                if (isDebug(1)) oldElement.style.removeProperty("background-color");
            }
            element.id = id;
            if (isDebug(1)) element.style.backgroundColor = "red";
        }

        // get geometric data from bounding box of element
        // ref can be an element or an element id
        function geo(ref, property) {

            // if ref is no element, it should be an element id
            var el = ref.getBoundingClientRect ? ref : document.getElementById(ref);

            // return geometric property of element
            return !el ? null : el.getBoundingClientRect()[property];
        }

        // return public interface
        return {
            // setters 
            set debugLevelManager(aManager) { debugLevelManager = aManager; }, 
            set logger(aLogger) { logger = aLogger; },

            // methods
            callPath:       callPath,
            debugWrite:     debugWrite,
            debug:          debug,
            debugRenderer:  debugRenderer,
            getIntProp:     getIntProp,
            hasClass:       hasClass,
            setClass:       setClass,
            switchId:       switchId,
            isDebug:        isDebug,
            geo:            geo
        };
    }());

    // *** divs *************************************************************************
    var getDivs = function (params) {

            // wrap div by an enclosing div
            function wrap(box) {
                var parent = box ? box.parentNode : null, 
                    wrap = document.createElement('div');
                if (parent) parent.insertBefore(wrap, box);
                if (box) wrap.appendChild(box);
                return wrap;
            }

            // shift node to document root (body)
            function shiftToBody(box) {

                var node = box.parentNode;
                while (node && node.parentNode) {
                    var parent = node.parentNode;
                    if (parent.nodeName.toUpperCase() === "BODY") {
                        parent.insertBefore(box, node);
                        return;
                    }
                    node = node.parentNode;
                }
            }

            var wWidth,       // window width, changes with resize
                wHeight,      // window height, changes with resize
                renderParams; // are set by rendering (e.g. after resize etc)

            // those two come from html
            var title =   document.getElementById(params.titleId), // id of title div
                content = document.getElementById(params.contentId); // id of content div

            // where title and content divs are: shift them to the document root, so 
            // that they are not affected by css settings of other elements
            shiftToBody(title);
            shiftToBody(content);

            // those are generated by javascript, wrapping title & content
            var titleBox =      wrap(title),      // extra div wrapping the title
                firstCols =     wrap(content),    // extra div wrapping columns on first page
                firstColsBox =  wrap(firstCols),  // ... and wrap this again (for columns)
                subScroll =     wrap(),           // extra div wrapping columns on other pages
                subBox =        wrap(subScroll),  // ... and wrap this again (for columns)

                rootScroll =    wrap(titleBox),   // primary scroll area
                rootBox =       wrap(rootScroll); // root div, contains all content

            rootScroll.appendChild(firstColsBox); // make wrapping div a child of root div
            rootScroll.appendChild(subBox);       // make wrapping div a child of root div
            
            // for debugging purposes only ...
            if (tools.isDebug(1)) {
              tools.setClass(titleBox,     "titleBox");
              tools.setClass(firstCols,    "firstCols");
              tools.setClass(firstColsBox, "firstColsBox");
              tools.setClass(subScroll,    "subScroll");
              tools.setClass(subBox,       "subBox");
              tools.setClass(rootScroll,   "rootScroll");
              tools.setClass(rootBox,      "rootBox");
            }

            // walk through all children of node, the one with the biggest height
            // determines the physical height of parent (yes, maybe the bounding box will 
            // also work, but perhaps it fails)
            function getRealHeight(node) {

                var top = tools.geo(node, "top"), bottom = top;

                for (var child = node.firstChild; child; child = child.nextSibling) {

                    // only elements have a bounding box
                    if (child.nodeType !== 1) continue;

                    var boxBottom = tools.geo(child, "bottom");
                    if (boxBottom > bottom) bottom = boxBottom;
                }

                return bottom - top;
            }

            // assign basic geometric properties to div
            function setup(box, position, overflow, top, left, width, height) {

                if (position !== null) box.style.position = position;
                if (overflow !== null) box.style.overflow = overflow;

                if (top !== null)    box.style.top    = top    + "px";
                if (left !== null)   box.style.left   = left   + "px";
                if (width !== null)  box.style.width  = width  + "px";
                if (height !== null) box.style.height = height + "px";
            }

            // set geometry of divs as necessary (part I, before doeing anything else)
            function setupGeometry() {

                var width = nettoWidth(), height = nettoHeight();

                setup(rootBox, "absolute", "hidden", 
                      renderParams.topMargin, renderParams.leftMargin, width, height);
                setup(rootScroll, "absolute", "hidden", 0, 0, width, height);
                setup(titleBox, "absolute", "hidden", 0, 0, width, height);

                // for debugging purposes only ...
                if (tools.isDebug(1)) {
                    rootScroll.style.backgroundColor   = "#DDDDDD";
                    titleBox.style.backgroundColor     = "#DDFFDD";
                    firstColsBox.style.backgroundColor = "#FFDDDD";
                    subBox.style.backgroundColor       = "#DDDDFF";
                }
            }

            // set geometry of divs as necessary (part II, after breaking the title div(s))
            function setupColsGeometry(titleBox, index, em) {

                var demandTitleHeight = getRealHeight(titleBox) + em,
                    width = nettoWidth(), height = nettoHeight(),
                    firstHeight = height - demandTitleHeight,
                    left = index * width;

                if (firstHeight < em)  firstHeight = em;

                setup(firstColsBox, "absolute", "hidden", demandTitleHeight, left, null, firstHeight);
                setup(firstCols, null, "hidden", null, null, width, firstHeight);

                setup(subBox, "absolute", null, 0, left + width, width, null);
                setup(subScroll, null, "hidden", null, null, null, height);
            }

            // create div for extra pages (like title divs)
            function mkComputedPage(left) {

                var computed = document.createElement('div');
                setup(computed, "absolute", null, 0, left, nettoWidth(), nettoHeight());
                tools.setClass(computed, "computedPage");

                // for debugging purposes only ...
                if (tools.isDebug(1)) computed.style.backgroundColor = "#DDFFDD";
                return computed;
            }

            // initially or after resize, store windows geometry and render options
            function updateWindowSize(params) {

                wWidth = window.innerWidth;
                wHeight = window.innerHeight;
                renderParams = params;

                tools.debug(1, "leftMargin: "     + renderParams.leftMargin + 
                	       " rightMargin: "   + renderParams.rightMargin + 
                	       " topMargin: "     + renderParams.topMargin + 
                	       " bottomMargin: "  + renderParams.bottomMargin);

            }

            // compute width available for text content
            function nettoWidth() {
                return wWidth - renderParams.leftMargin - renderParams.rightMargin;
            }

            // compute height available for text content
            function nettoHeight() {
                return wHeight - renderParams.topMargin - renderParams.bottomMargin;
            }

            // setup css for multicol divs
            function setColumnsNum(nCols, columnGap) {

                firstCols.style.webkitColumnCount = nCols;
                firstCols.style.columnCount = nCols;

                firstCols.style.columnFill = "balance";
                firstCols.style.webkitColumnFill = "balance";

                firstCols.style.columnGap = columnGap + "px";
                firstCols.style.webkitColumnGap = columnGap + "px";

                subScroll.style.webkitColumnCount = nCols;
                subScroll.style.columnCount = nCols;

                subScroll.style.columnFill = "balance";
                subScroll.style.webkitColumnFill = "balance";

                subScroll.style.columnGap = columnGap + "px";
                subScroll.style.webkitColumnGap = columnGap + "px";

                return nCols;
            }

            // compute number of columns depending on the window geometry
            // this is normally overloaded by the calling context (parameter ncols)
            function computeColumnsNum(columnGap) {

                var nCols;

                if (wWidth < 300) nCols = 1;
                else if (wWidth < 550) nCols = 2;
                else if (wWidth < 820) nCols = 3;
                else if (wWidth < 1400) nCols = 4;
                else nCols = 5;

                setColumnsNum(nCols, columnGap);

                return nCols;
            }

            // return public interface
            return {
                // getters for static properties
                get rootScroll()   { return rootScroll; }, 
                get titleBox()     { return titleBox; }, 
                get firstColsBox() { return firstColsBox; }, 
                get firstCols()    { return firstCols; }, 
                get subScroll()    { return subScroll; },

                // getters for computed properties
                get nettoWidth()   { return nettoWidth(); }, 
                get nettoHeight()  { return nettoHeight(); },

                // methods
                setupGeometry:     setupGeometry,
                setupColsGeometry: setupColsGeometry,
                updateWindowSize:  updateWindowSize,
                setColumnsNum:     setColumnsNum,
                computeColumnsNum: computeColumnsNum,
                mkComputedPage:    mkComputedPage
            }
        };

    // erst nach onload body initialisieren ...
    var divs;

    // *** breaks *************************************************************************
    var breaks = (function () {

        // index and name of first word on page
        var pageBreaks = {};

        // test if strict mode is activated
        var hasStrictMode = (function () {
	    // ### RaKl 
	    return true;
            return this === undefined;
        }());

        // create debug message for page break
        function debugPageBreak(level, index) {

            pageBreak = pageBreaks[index];

            var caller = hasStrictMode ? null : tools.callPath(arguments.callee.caller, 0);
            tools.debugWrite(level, caller, "[" + index + "] --> (" + 
                                    pageBreak.pos + ",'" + pageBreak.word + "')");
        }

        // get page break
        function pageBreak(index) {
            return pageBreaks[index];
        }

        // reset page breaks
        function initBreaks() {
            pageBreaks = {};
        }

        // set page break
        function storeBreak(index, pos, text) {
            pageBreaks[index] = { pos: pos, word: text };
            // debugPageBreak(2, index);
        }

        // return public interface
        return {
            debugPageBreak: debugPageBreak,
            initBreaks: initBreaks,
            pageBreak: pageBreak,
            storeBreak: storeBreak
        };
    }());

    // *** text *************************************************************************
    var text = (function () {

        
        // copy clones of all siblings following node to dest
        function copyFollowUps(dest, node) {

            var next = node.nextSibling;
            while (next !== null) {
                var nextClone = next.cloneNode(true);
                dest.appendChild(nextClone);
                next = next.nextSibling;
            }
        }

        // We are inside the DOM, somewhere at position "pos". The task is to split the DOM 
        // so, that all nodes "right" of that position go to "dest". We start from pos and 
        // go towards the document root up to "container".
        function breakRootPage(pos, container, dest) {

            if (!pos) return;

            // work through the DOM up to the conatiner
            var posRoot = pos;
            var copy = posRoot.cloneNode(true);
            while (posRoot.parentNode !== container) {
                posRoot = posRoot.parentNode;
                var fatherClone = posRoot.cloneNode(false);
                fatherClone.appendChild(copy);
                copyFollowUps(fatherClone, pos);
                copy = fatherClone;
                pos = posRoot;
            }

            // final cleanup
            dest.appendChild(copy);
            copyFollowUps(dest, posRoot);
        }

        // HTML muticol scrolling stops at the content end, but we want it page wise,
        // so we create extra dummy columns
        function addDummyCol(scrollBox, index, colWidth, height) {

            var dummyCol = document.createElement('div');

            dummyCol.style.width = colWidth + "px";
            dummyCol.style.height = height + "px";
            if (tools.isDebug(1)) dummyCol.style.backgroundColor = index ? "#DDFFDD" : "#FFDDFF";

            dummyCol.id = "dummyCol_" + index;
            tools.setClass(dummyCol, "dummyCol");
            scrollBox.appendChild(dummyCol);
        }

        // remove all "computed" pages in root scroll area
        function cleanupRootScroll(box) {

            var child = box.firstChild;
            while (child) {
                var toCheck = child;
                child = child.nextSibling;
                if (tools.hasClass(toCheck, "computedPage")) box.removeChild(toCheck);
            }
        }


        // return public interface
        return {
            breakRootPage: breakRootPage,
            addDummyCol: addDummyCol,
            cleanupRootScroll: cleanupRootScroll
        };
    }());

    // *** engine *************************************************************************
    return (function () {

        var traceWord = 0,             // set to 0 to disable debugging

            titleBreaks = 0,           // how many page breaks in title ?
            contentBreaks = 0,         // how many page breaks in content ?
            rootWinIndex = 0,          // which root window is currently in view ?
            subScrollWinIndex = 0,     // which subscroll windows is currently in view ?

            wordCount = 0, // during render, while computing the page breaks, this variable 
                           // stores the current number of words to reposition after a resize operation

            lastBreak = 0, // position of last word in content, avoid infinite loops with small contents

            currentPage = undefined, // during render, currentPage is computed by currentWord for
                                     // correct repositioning after resize

            currentWord = 0, // current position of content (the first word of the page)
            toleratedOverlap = 50, // tolerated overlap without assuming a bug
            columnGap,       // from css, normally overloaded by the calling context (parameter columnGap)
            nCols,           // from css, normally overloaded by the calling context (parameter nCols)
            em,              // from css, not overloaded by the calling context
            scrollStep;      // amount of scrolling pagewise horizontal or vertical (float)

        // get page break position
        function pageBreakPos(index) {
            var thisBreak = breaks.pageBreak(index);
            return thisBreak ? thisBreak.pos : wordCount + 1;
        }

        // move one page right, either in root window or in sub scroll area
        function pageRight() {
            if (rootWinIndex <= titleBreaks) return scrollFirst(1);
            else return scrollSecond(1);
        }

        // move one page left, either in root window or in sub scroll area
        function pageLeft() {
            if (subScrollWinIndex == 0) return scrollFirst(-1);
            else return scrollSecond(-1);
        }

        // is current page the first one ?
        function isFirstPage() {
            return rootWinIndex == 0;
        }

        // is current page the last one ?
        function isLastPage() {
            return subScrollWinIndex >= contentBreaks - 1;
        }

        // display first page
        function firstPage() {

            tools.debug(2, "firstPage");
            reposition(0);
            currentWord = pageBreakPos(0);

            return true;
        }

        // display last page
        function lastPage() {

            var lastPageIndex = titleBreaks + contentBreaks;
            tools.debug(1, "lastPage(" + lastPageIndex + ")");

            reposition(lastPageIndex);
            currentWord = pageBreakPos(lastPageIndex);

            return true;
        }
 
        // get current page number
        function getCurrentPagerNumber() {

            var nr = rootWinIndex + subScrollWinIndex;
            tools.debug(2, "currentPageNumber: " + nr);
            return nr;
        }

        // get total number of pages
        function getNumberOfPages() {

            var nr = titleBreaks + contentBreaks + 1;
            tools.debug(1, "numerOfPages: " + nr);
            return nr;
        }

        // display page at index
        function reposition(toPage) {

            tools.debug(2, "toPage(" + currentWord + "): " + toPage + " titleBreaks: " + titleBreaks);

            // requested page is a title page
            if (toPage <= titleBreaks) {
                rootWinIndex = toPage;
                subScrollWinIndex = 0;
                divs.subScroll.scrollLeft = 0;

            // requested page is content with one column
            } else if (nCols == 1) {
                rootWinIndex = titleBreaks + 1;
                subScrollWinIndex = toPage - rootWinIndex;
                divs.subScroll.scrollTop = Math.floor(subScrollWinIndex * scrollStep);

            // requested page is content with more than one column
            } else {
                rootWinIndex = titleBreaks + 1;
                subScrollWinIndex = toPage - rootWinIndex;
                divs.subScroll.scrollLeft = Math.floor(subScrollWinIndex * scrollStep);
            }

            divs.rootScroll.scrollLeft = divs.nettoWidth * rootWinIndex;
        }

        // scroll root scroll area one page left (by -1) or right (by 1)
        function scrollFirst(direction) {

            // check left margin
            if (rootWinIndex + direction < 0) {
                rootWinIndex = 0;
                return false;
            }
            if (!breaks.pageBreak(rootWinIndex + direction)) return false;

            reposition(rootWinIndex + direction);
            currentWord = pageBreakPos(rootWinIndex);
            return true;
        }

        // scroll sub scroll area one page left (by -1) or right (by 1)
        function scrollSecond(direction) {

            // compute scroll offset (in px)
            var offset = Math.floor((subScrollWinIndex + direction) * scrollStep);

            // content has one column
            if (nCols == 1) {
                var dummyTop = tools.geo("dummyCol_0", "top"),
                    scrollBottom = tools.geo(divs.subScroll, "bottom");

                // stop at bottom margin
                if ((direction > 0) && ((dummyTop < scrollBottom) || 
                    (offset > divs.subScroll.scrollHeight))) return false;

                subScrollWinIndex += direction;
                divs.subScroll.scrollTop = offset;

            // content has more than one column
            } else {
                var dummyLeft = tools.geo("dummyCol_0", "left"),
                    scrollRight = tools.geo(divs.subScroll, "right");

                // stop at right margin
                if ((direction > 0) && ((dummyLeft < scrollRight) || 
                    (offset > divs.subScroll.scrollWidth))) return false;

                subScrollWinIndex += direction;
                divs.subScroll.scrollLeft = offset;
            }

            currentWord = pageBreakPos(rootWinIndex + subScrollWinIndex);
            return true;
        }

        // find next node with attribute "wordTrigger" in subtree of "node"
        // with root node "scrollRoot", which is not in current viewport
        function findRootBreak(node, wordTrigger, scrollRoot) {

            for (var child = node.firstChild; child; child = child.nextSibling) {

                // only elements have class attributes
                if (child.nodeType !== 1) continue;

                // if child node doesn't have the requested attribute look in subtree
                var wc = child.getAttribute(wordTrigger);
                if (!wc) {
                    var upTo = findRootBreak(child, wordTrigger, scrollRoot);
                    if (upTo) return upTo;
                    else continue;
                } else wordCount = parseInt(wc);

                // is the right or bottom margin of next word position not in viewport ?
                if ((wordCount > lastBreak) && 
                      (tools.geo(child, "right") > tools.geo(scrollRoot, "right") + 10 || 
                       tools.geo(child, "bottom") > tools.geo(scrollRoot, "bottom"))) {
                    lastBreak = wordCount;
                    return child;
                }

                // mark first page containing stored word position as current
                if ((currentPage == undefined) && (wordCount >= currentWord)) {
                    currentPage = titleBreaks;
                    tools.switchId(child, "currentPos");
                    tools.debug(2, "set currentPage(" + currentWord + ": " + 
                    	           child.textContent + ") to " + currentPage);
                }

                if (traceWord) console.log("wc: " + wordCount + " [" + child.textContent + "]");
            }

            return null;
        }

        function hasMultiColBug(node, wordTrigger, scrollRoot) {

            for (var child = node.firstChild; child; child = child.nextSibling) {

                // only elements have class attributes
                if (child.nodeType !== 1) continue;

                // if child node doesn't have the requested attribute look in subtree
                var wc = child.getAttribute(wordTrigger);
                if (!wc) {
                    if (hasMultiColBug(child, wordTrigger, scrollRoot)) return true;
                    else continue;
                } else wordCount = parseInt(wc);

                // tools.debug(1,"text " + child.textContent + " bottom: " +
                //    tools.geo(child, "bottom") + " border: " + 
                //    tools.geo(scrollRoot, "bottom"));

                // is the bottom margin of next word position not in viewport ?
                if ((tools.geo(child, "bottom") > tools.geo(scrollRoot, "bottom") + toleratedOverlap)) {
                    tools.debug(1,"found multiCol bug at wordpos: " + wordCount +
                                  " text: '" + child.textContent + "'");
                    return true;
                }
            }

            return false;
        }

        // register (store) word index of page breaks
        function registerSubScrollBreaks(node, wordTrigger, scrollRoot) {

            for (var child = node.firstChild; child; child = child.nextSibling) {

                // only elements have class attributes
                if (child.nodeType !== 1) continue;

                // if child node doesn't have the requested attribute look in subtree
                var wc = child.getAttribute(wordTrigger);
                if (!wc) {
                    registerSubScrollBreaks(child, wordTrigger, scrollRoot);
                    continue;
                } else wordCount = parseInt(wc);

                // multicol: is the left margin of next word position not in viewport ?
                if ((nCols > 1) && (tools.geo(child, "left") >= 
                         tools.geo(scrollRoot, "left") + Math.floor(contentBreaks * scrollStep))) {
                    contentBreaks++;
                    breaks.storeBreak(titleBreaks + contentBreaks, wordCount, child.textContent);

                // one column: is the top margin of next word position not in viewport ?
                } else if ((nCols == 1) && (tools.geo(child, "top") >= 
                         tools.geo(scrollRoot, "top") + Math.floor(contentBreaks * scrollStep))) {
                    contentBreaks++;
                    breaks.storeBreak(titleBreaks + contentBreaks, wordCount, child.textContent);
                }

                // mark first page containing stored word position as current
                if ((currentPage == undefined) && (wordCount >= currentWord)) {
                    currentPage = titleBreaks + contentBreaks;
                    tools.switchId(child, "currentPos");
                    tools.debug(2, "set currentPage(" + currentWord + ": " + 
                                   child.textContent + ") to " + currentPage);
                }
            }
        }

        // start recursion to register (store) word index of content page breaks
        function registerContentBreaks() {
            registerSubScrollBreaks(divs.subScroll, "data-wc", divs.subScroll);
        }

        // setup geometry of all generated divs
        function setupGeometry() {

            // remove all "computed" pages in root scroll area
            text.cleanupRootScroll(divs.rootScroll);

            // set geometry of divs as necessary (part I, before doeing anything else)
            divs.setupGeometry();

            // reset page breaks
            titleBreaks = 0;
            contentBreaks = 0;
            wordCount = 0;
            lastBreak = 0;
            currentPage = undefined;

            // init page breaks & store begin of document as extra page break
            breaks.initBreaks();
            breaks.storeBreak(0, 0, "* top *");

            // traceWord = 1;
            var addTitle = divs.titleBox,  // running title text data
                upTo = findRootBreak(addTitle, "data-wc", addTitle); // look out for page break in title

            while (upTo) {

                titleBreaks++;

                // insert extra page for title break
                var newPage = divs.mkComputedPage(divs.nettoWidth * titleBreaks);
                text.breakRootPage(upTo, addTitle, newPage);
                divs.rootScroll.insertBefore(newPage, divs.firstColsBox);
                breaks.storeBreak(titleBreaks, wordCount, upTo.textContent);

                // update running title text data and look out for next page break in title
                addTitle = newPage;
                upTo = findRootBreak(addTitle, "data-wc", addTitle);
            }

            // traceWord = 0;
            // set geometry of divs as necessary (part II, after breaking the title div(s))
            divs.setupColsGeometry(addTitle, titleBreaks, em);
        }

        // copy content from root sroll area to sub scroll area and add dummy columns to sub scroll 
        // area as HTML muticol scrolling stops at the content end, but we want it page wise, so we 
        // create extra dummy columns
        function fillSubScroll() {

            // remove existing sub scroll content
            var child = divs.subScroll.firstChild;
            while (child) {
                var toRemove = child;
                child = child.nextSibling;
                divs.subScroll.removeChild(toRemove);
            }

            // don't increment contentBreaks here, (done in registerContentBreaks())
            // look out for page break in title
            var upTo = findRootBreak(divs.firstCols, "data-wc", divs.firstCols); 
            if (!upTo) {
                tools.debug(1, "no content breaks");
                return;
            }

            text.breakRootPage(upTo, divs.firstCols, divs.subScroll);

            // add dummy columns
            var colWidth = (divs.nettoWidth / nCols) - columnGap;
            text.addDummyCol(divs.subScroll, 0, colWidth, 0);
            for (var i = 0; i < nCols; i++)
            text.addDummyCol(divs.subScroll, i + 1, colWidth, divs.nettoHeight);

            // register (store) word index of content page breaks
            registerContentBreaks();
        }

        // scroll offset depends on number of columns and window geometry
        function getScrollStep() {

            if (nCols == 1) {
                scrollStep = divs.nettoHeight - em;
            } else {
	    	var isChrome = navigator.appVersion.match(/\bChrome\//);
                var textSpace = divs.nettoWidth - (nCols - 1) * columnGap;
		var colSpace = (textSpace / nCols);
		if (!isChrome) colSpace = Math.floor(colSpace);
                scrollStep = (colSpace + columnGap) * nCols;

                tools.debug(2, ">> textSpace=nettoWidth-(nCols-1)*columnGap: " + 
                               textSpace + "=" + divs.nettoWidth + "-(" + nCols + "-1)*" + columnGap); 
                tools.debug(2, ">> colSpace=textSpace/nCols: " + 
                               colSpace + "=" + textSpace + "/" + nCols ); 
                tools.debug(2, ">> scrollstep=(colSpace+columnGap)*nCols: " + 
                               scrollStep + "=(" + colSpace + "+" + columnGap + ")*" + nCols); 
                tools.debug(2, ">> versus nettoWidth+gap: " + (divs.nettoWidth + columnGap) + "=" + 
                               divs.nettoWidth + "+" + columnGap);
            }
        }

        // new rendering (compute page breaks) after each resize and once at the beginning
        function render(params) {

	    var rv = null;

            tools.debug(1, "*** render, wordPos: " + params.wordPos + ", nCols: " + params.nCols);

            // if requested, display page at word position
            if (params.wordPos !== null && params.wordPos !== undefined) 
                 currentWord = params.wordPos;

            // initially or after resize, store windows geometry and render options
            divs.updateWindowSize(params);

            // computation of one em
            em = tools.getIntProp(divs.firstCols, 'font-size');

            // store columnGap if supplied, else compute it
            if (params.columnGap) columnGap = params.columnGap;
            else columnGap = em;

            // set tolated overlap in multicolumn mode, beyond a bug is assumed
            if (params.toleratedOverlap) toleratedOverlap = params.toleratedOverlap;

            // store number of columns if supplied, else compute it
            if (params.nCols) nCols = divs.setColumnsNum(params.nCols, columnGap);
            else nCols = divs.computeColumnsNum(columnGap);
            // nCols = divs.setColumnsNum(1, columnGap);

            tools.debug(1, "em: " + em + " columnGap: " + columnGap + " nCols: " + nCols);

            // go through further initializations
            setupGeometry();

            if (nCols > 1 && hasMultiColBug(divs.firstCols, "data-wc", divs.firstCols)) {
                 tools.debug(1,"reset number of columns from " + nCols + 
                               " to 1 due to multiCol bug in renderer");
                 nCols = divs.setColumnsNum(1, columnGap);
                 rv = { multiColBug : true }
            };

            getScrollStep();
            fillSubScroll();
            reposition(currentPage);

            return rv;
        }

        // initial setup (only once)
        function init(params) {

            // replace default debugging with customized debugging
            if (params.debugLevelManager) tools.debugLevelManager = params.debugLevelManager;
            if (params.logger) tools.logger = params.logger;

            tools.debug(1, "*** init, titleId: " + params.titleId + ", contentId: " + params.contentId);
            tools.debugRenderer();

            // generate divs for title and content
            divs = getDivs(params);
        }

        // return public interface
        return {
            // getters for computed properties
            get currentWord()         { return currentWord; }, 
            get isFirstPage()         { return isFirstPage(); }, 
            get isLastPage()          { return isLastPage(); },
            get currentPagerNumber()  { return getCurrentPagerNumber(); },
            get numberOfPages()       { return getNumberOfPages(); },

            // members
            init:         init,
            pageLeft:     pageLeft,
            pageRight:    pageRight,
            firstPage:    firstPage,
            lastPage:     lastPage,
            render:       render
        }

        // interface of init(params)
        // params: { 
        //    titleId:            string, 
        //    contentId:          string, 
        //    debugLevelManager:  function, 
        //    logger:             function
        // };

        // interface of render(params)
        // params: {
        //    wordPos     : number,
        //    nCols       : number,
        //    columnGap   : number,
        //    leftMargin  : number,
        //    rightMargin : number,
        //    topMargin   : number,
        //    bottomMargin: number
        // }
    }());

}());


// Testen
// ======
// 
// Teil I
// ------
// 
//    - Blaettern vorwaerts, rueckwaerts: Umbruch korrekt ?
//    - Blaettern einspaltige/mehrspaltige Texte
//    - Blaettern in Titelei, im Content
//    - kleine Texte (eine Seite), lange Titel (mehrere Seiten)
//    - strict mode aktiviert / deaktiviert - debuglevel 0,1,2
//    - resize: Anzahl Spalten, bleibt erstes Wort der Seite sichtbar ?
//    - werden dummy-Spalten am Ende korrekt erzeugt ?
//    - Wechsel am Anfang/Ende zum vorigen / naechsten Artikel ?
// 
// Teil II
// -------
// 
//    - Aufruf am Anfang, Position Mitte, am Ende
//    - default-debugging ersetzen
